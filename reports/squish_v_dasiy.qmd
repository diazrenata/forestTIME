---
title: "Comparison of daisy chain and tree number"
format: 
  gfm: 
    df-print: kable
editor: source
---

## Context

The "daisy chain" method is to link backwards in time using `PREV_TRE_CN` and `CN`. The "tree number" method is to concatenate columns `STATECD`, `UNITCD`, `COUNTYCD`, `PLOT`, `SUBP`, and `TREE` to get a unique tree number for each tree. In principle these _should_ give equivalent outcomes, but we don't know if they really always do!

## Code 

```{r}
#| label: setup

library(arrow)
library(dplyr)
library(ggplot2)

state_number <- c(1,2,4,5,6,8)
arrow_dir <- "data/arrow"

```


```{r}
#| label: create unique number table

tree <- open_dataset(
  here::here(arrow_dir, "TREE_RAW"),
  partitioning = c("STATECD", "COUNTYCD"),
  format = "csv",
  hive_style = T,
  col_types = schema(
    CN = float64(),
    TREE_FIRST_CN = float64()
  )) |>
  filter(STATECD %in% state_number) |>
  compute()
```


```{r}
#| label: open daisy chain table

join_cns <-  open_dataset(
  here::here(arrow_dir, "TREE_CN_JOIN"),
  partitioning = c("STATECD", "COUNTYCD"),
  format = "csv",
  hive_style = T,
  col_types = schema(
    CN = float64(),
    TREE_FIRST_CN = float64()
  )) |>
  filter(STATECD %in% state_number) |>
  compute()

```


```{r}
#| label: create unmatched_cns table

unmatched_cns <- join_cns |>
  left_join(tree) |>
  select(STATECD, TREE_FIRST_CN, TREE_UNIQUE_ID) |> 
  distinct() |>
  collect() |> 
  group_by(STATECD, TREE_FIRST_CN) |>
  mutate(n_NUM = n()) |>
  group_by(STATECD, TREE_UNIQUE_ID) |>
  mutate(n_FIRST_CN = n()) |>
  ungroup() |>
  filter(n_NUM > 1 |
           n_FIRST_CN > 1)
# 
# unmatched_deeper_dives <- join_cns |>
#   left_join(tree) |>
#   filter(TREE_UNIQUE_ID %in% unmatched_cns$TREE_UNIQUE_ID) |>
#   arrange(TREE_UNIQUE_ID, CYCLE) |>
#   collect() |>
#   mutate(TREE_FIRST_CN = as.character(TREE_FIRST_CN),
#          CN = as.character(CN),
#          PREV_TRE_CN = as.character(PREV_TRE_CN)) |>
#   group_by(TREE_UNIQUE_ID) |>
#   mutate(CN_break = TREE_FIRST_CN != CN[1]) |>
#   mutate(prev_break = lag(CN_break),
#          prev_status = lag(STATUSCD)) |>
#   mutate(is_break_point = ifelse(CN_break, ifelse(prev_break, FALSE, TRUE), FALSE)) 


```

### Alabama

```{r}

al <- filter(unmatched_cns, STATECD == 1)

```

All 152 mismatches in Alabama take the form of 2 "TREE_UNIQUE_IDS" per 1 "TREE_FIRST_CN".

```{r}

al_mismatches <- tree |>
  filter(STATECD == 1,
         TREE_UNIQUE_ID %in% al$TREE_UNIQUE_ID) |>
  collect() |>
  left_join(al) |>
  arrange(TREE_FIRST_CN, CYCLE) |>
  mutate(across(contains("CN"), as.character))

al_nplots <- al_mismatches |>
  group_by(TREE_FIRST_CN) |>
  summarize(nplots = length(unique(PLOT)))

```

In all of these instances, a PREV_TRE_CN links to a tree previously found on a different plot. For example, this tree is on plot 93 for 2001 and 2009, and then on plot 133 for 2016. This gives it a new UNIQUE_ID in 2016.

:::callout-note

Are these accurate, and the plot spatial arrangement changed, or in error?

:::

```{r}

head(al_mismatches |> select(TREE_FIRST_CN, TREE_UNIQUE_ID, INVYR, PLOT), 3)

```


### Alaska

```{r}

ak <- filter(unmatched_cns, STATECD == 2)

```

All 17800 (!!) mismatches in Alaska have 2 TREE_FIRST_CNs per TREE_UNIQUE_ID. 

```{r}

ak_mismatches <- tree |>
  filter(STATECD == 2,
         TREE_UNIQUE_ID %in% ak$TREE_UNIQUE_ID) |>
  left_join(join_cns) |>
  arrange(TREE_UNIQUE_ID, CYCLE) |>
  collect() |> 
  mutate(across(contains("CN"), as.character))

ak_cycle2 <- ak_mismatches |>
  filter(CYCLE == 2) 

unique(ak_cycle2$PREV_TRE_CN)

ak_cycle2_all <- tree |> filter(STATECD == 2, CYCLE ==2) |> collect() 

unique(ak_cycle2_all$PREV_TRE_CN)


ak_remaining_mismatches <- ak_mismatches |>
  filter(!(TREE_UNIQUE_ID %in% ak_cycle2_all$TREE_UNIQUE_ID))

nrow(ak_mismatches |>
  group_by(TREE_UNIQUE_ID) |>
  summarize(nspp = length(unique(SPCD))) |>
  filter(nspp > 1))

```

There is a deeper dive to be done, but there are no non-NA PREV_TRE_CNs recorded for CYCLE=2 in Alaska. There are 8873 trees where that would cause a break in the chain, of 8899 unique trees with a mismatch. The remaining 52 skip from CYCLE=1 to CYCLE=3 and have an NA for PREV_TRE_CN in CYCLE=3. Overall, 225 trees (of the mismatch pool) show inconsistent species. 

